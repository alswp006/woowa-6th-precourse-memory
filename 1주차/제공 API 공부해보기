## API ê³µë¶€ ëª©ì 

- ì´ë²ˆ ìš°ì•„í•œ í…Œí¬ì½”ìŠ¤ í”„ë¦¬ì½”ìŠ¤ 1ì£¼ì°¨ ê¸°ëŠ¥ì„ ì½ì–´ë³´ë‹¤ê°€ í”„ë¦¬ì½”ìŠ¤ì—ì„œ ì œê³µí•˜ëŠ” APIë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤ëŠ” ìš”êµ¬ì‚¬í•­ì— APIë¥¼ ê³µë¶€í•´ì„œ ì‚¬ìš©í•˜ë©´ ë” ë‚˜ì€ ì½”ë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆê² ì§€ë¼ëŠ” ìƒê°ê³¼ ì˜ êµ¬ì„±ëœ APIë¥¼ ê³µë¶€í•´ë³´ë©´ ì €ì˜ ì„±ì¥ì—ë„ í° í˜ì´ ë  ê²ƒ ê°™ì•„ì„œ ê³µë¶€ë¥¼ í•´ë³´ë ¤ í•©ë‹ˆë‹¤!

# camp.nextstep.edu.missionutils

- ì´ë²ˆ ìš°ì•„í•œ í…Œí¬ì½”ìŠ¤ 1ì£¼ì°¨ ìˆ«ìì•¼êµ¬ê²Œì„ì—ì„œëŠ” `camp.nextstep.edu.missionutils` APIë¥¼ ì œê³µí•˜ì—¬ì£¼ì—ˆìŠµë‹ˆë‹¤.
- ê·¸ë¦¬ê³  ì´ APIì—ëŠ” Randoms í´ë˜ìŠ¤ì™€ Console í´ë˜ìŠ¤ê°€ ìˆìŠµë‹ˆë‹¤.
- ìš”êµ¬ì‚¬í•­ì—ì„œëŠ” ì´ APIë¥¼ ì–´ë–»ê²Œ ì‚¬ìš©í• ì§€ ê°€ì´ë“œê°€ ìˆì—ˆìŠµë‹ˆë‹¤!
    - â€œRandom ê°’ ì¶”ì¶œì€Â `camp.nextstep.edu.missionutils.Randoms`ì˜Â `pickNumberInRange()`ë¥¼ í™œìš©í•©ë‹ˆë‹¤.â€
    - â€œì‚¬ìš©ìê°€ ì…ë ¥í•˜ëŠ” ê°’ì€Â `camp.nextstep.edu.missionutils.Console`ì˜Â `readLine()`ì„ í™œìš©í•©ë‹ˆë‹¤.â€
- ê·¸ëŸ¼ ìš°ì„  Randomsí´ë˜ìŠ¤ì˜ ì½”ë“œë¥¼ ê³µë¶€í•´ë³´ê² ìŠµë‹ˆë‹¤!

## Randoms

```java
package camp.nextstep.edu.missionutils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

public class Randoms {
    private static final Random defaultRandom = ThreadLocalRandom.current();

    private Randoms() {
    }

    public static int pickNumberInList(final List<Integer> numbers) {
        validateNumbers(numbers);
        return numbers.get(pickNumberInRange(0, numbers.size() - 1));
    }

    public static int pickNumberInRange(final int startInclusive, final int endInclusive) {
        validateRange(startInclusive, endInclusive);
        return startInclusive + defaultRandom.nextInt(endInclusive - startInclusive + 1);
    }

    public static List<Integer> pickUniqueNumbersInRange(
        final int startInclusive,
        final int endInclusive,
        final int count
    ) {
        validateRange(startInclusive, endInclusive);
        validateCount(startInclusive, endInclusive, count);
        final List<Integer> numbers = new ArrayList<>();
        for (int i = startInclusive; i <= endInclusive; i++) {
            numbers.add(i);
        }
        return shuffle(numbers).subList(0, count);
    }

    public static <T> List<T> shuffle(final List<T> list) {
        final List<T> result = new ArrayList<>(list);
        Collections.shuffle(result);
        return result;
    }

    private static void validateNumbers(final List<Integer> numbers) {
        if (numbers.isEmpty()) {
            throw new IllegalArgumentException("numbers cannot be empty.");
        }
    }

    private static void validateRange(final int startInclusive, final int endInclusive) {
        if (startInclusive > endInclusive) {
            throw new IllegalArgumentException("startInclusive cannot be greater than endInclusive.");
        }
        if (endInclusive == Integer.MAX_VALUE) {
            throw new IllegalArgumentException("endInclusive cannot be greater than Integer.MAX_VALUE.");
        }
        if (endInclusive - startInclusive >= Integer.MAX_VALUE) {
            throw new IllegalArgumentException("the input range is too large.");
        }
    }

    private static void validateCount(final int startInclusive, final int endInclusive, final int count) {
        if (count < 0) {
            throw new IllegalArgumentException("count cannot be less than zero.");
        }
        if (endInclusive - startInclusive + 1 < count) {
            throw new IllegalArgumentException("count cannot be greater than the input range.");
        }
    }
}
```

- ìš°ì„  Randomsì˜ ìƒì„±ìë¥¼ ì œì™¸í•œ ëª¨ë“  í•„ë“œì™€ ë©”ì†Œë“œëŠ” staticìœ¼ë¡œ ì •ì˜ë˜ì–´ ìˆì–´ ê°ì²´ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³  ë°”ë¡œ í´ë˜ìŠ¤ë¥¼ í˜¸ì¶œí•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ê·¸ë¦¬ê³  defaultRandomì´ë¼ëŠ” í•„ë“œê°€ privateí•œ Random íƒ€ì…ì˜ ìƒìˆ˜ë¡œ ì„ ì–¸ë˜ê³  ThreadLocalRandom.current()ë¡œ ì´ˆê¸°í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
- ê·¸ëŸ¬ë©´ ThreadLocalRandom.current()ì— ëŒ€í•´ì„œ ë¨¼ì € ê³µë¶€í•´ë³´ê² ìŠµë‹ˆë‹¤!

### ThreadLocalRandom.current()

- ThreadLocalRandom í´ë˜ìŠ¤ì˜ ì„ ì–¸ë¶€ë¥¼ ë³´ë©´ java.utill.Randomì„ ìƒì†ë°›ê³  ìˆìŠµë‹ˆë‹¤.
    
    ```java
    public class ThreadLocalRandom extends Random
    ```
    
- ê·¸ë¦¬ê³  current() ë©”ì†Œë“œë¥¼ ë³´ë©´ U.getInt(Thread.currentThread(), PROBE)ê°€ 0ì´ë©´ localinit()ë¥¼ ì‹¤í–‰ì‹œí‚¤ê³  instanceë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    
    ```java
    public static ThreadLocalRandom current() {
            if (U.getInt(Thread.currentThread(), PROBE) == 0)
                localInit();
            return instance;
        }
    ```
    
    - instanceëŠ” ThreadLocalRandomí´ë˜ìŠ¤ì˜ ê°ì²´ì´ë‹¤. ê·¸ë ‡ë‹¤ë©´ ì´ ë©”ì†Œë“œëŠ” ThreadLocalRandomê°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì†Œë“œë¼ê³  ìƒê°í•˜ë©´ ë  ê²ƒ ê°™ìŠµë‹ˆë‹¤!
        
        ```java
        private static final ThreadLocalRandom instance = new ThreadLocalRandom();
        ```
        
- ë©”ì†Œë“œì˜ ì„¤ëª…ì„ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
    - â€œReturns the current thread's ThreadLocalRandom object. Methods of this object should be called only by the current thread, not by other threads. Returns: the current thread's ThreadLocalRandomâ€
    - â€œí˜„ì¬ ìŠ¤ë ˆë“œì˜ ThreadLocalRandom ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ì´ ê°œì²´ì˜ ë©”ì„œë“œëŠ” ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì•„ë‹Œ í˜„ì¬ ìŠ¤ë ˆë“œì—ì„œë§Œ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤. ë°˜í™˜: í˜„ì¬ ìŠ¤ë ˆë“œì˜ ThreadLocalRandomâ€
- ê·¸ë ‡ë‹¤ë©´ ThreadLocalRandom.current()ìœ¼ë¡œ í˜„ì¬ ìŠ¤ë ˆë“œì˜ ThreadLocalRandom ê°ì²´ì˜ ì°¸ì¡°ê°’ì„ defaultRandomì— ë„£ì–´ì¤¬ë‹¤ê³  ìƒê°í•´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ì´ì œ ìš°ë¦¬ê°€ ì‚¬ìš©í•´ì•¼í•˜ëŠ” `pickNumberInRange` ë¼ëŠ” ë©”ì†Œë“œë¥¼ í™•ì¸í•´ë³´ê² ìŠµë‹ˆë‹¤!

### pickNumberInRange()

```java
public static int pickNumberInRange(final int startInclusive, final int endInclusive) {
        validateRange(startInclusive, endInclusive);
        return startInclusive + defaultRandom.nextInt(endInclusive - startInclusive + 1);
    }
```

- ìš°ì„  pickNumberInRange() ë©”ì†Œë“œëŠ” ë§¤ê°œë³€ìˆ˜ë¡œ (final int startInclusive, final int endInclusive)ë¼ëŠ” ë‘ ì •ìˆ˜ê°’ì„ ë°›ìŠµë‹ˆë‹¤.
- ê·¸ë¦¬ê³  validateRange() ë©”ì†Œë“œì— ë§¤ê°œë³€ìˆ˜ ê°’ë“¤ì„ ë„£ì–´ì¤ë‹ˆë‹¤.
    
    ```java
    private static void validateRange(final int startInclusive, final int endInclusive) {
            if (startInclusive > endInclusive) {
                throw new IllegalArgumentException("startInclusive cannot be greater than endInclusive.");
            }
            if (endInclusive == Integer.MAX_VALUE) {
                throw new IllegalArgumentException("endInclusive cannot be greater than Integer.MAX_VALUE.");
            }
            if (endInclusive - startInclusive >= Integer.MAX_VALUE) {
                throw new IllegalArgumentException("the input range is too large.");
            }
        }
    ```
    
    - validateRange()ë©”ì†Œë“œëŠ” startInclusiveê°€ endInclusiveë³´ë‹¤ í¬ê±°ë‚˜ endInclusiveê°€ ì •ìˆ˜ê°’ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ì„ ë•Œ  endInclusive - startInclusiveê°€ ì •ìˆ˜ê°’ ë²”ìœ„ë³´ë‹¤ í´ ë•Œ ì˜¤ë¥˜ë¥¼ ë˜ì ¸ì£¼ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
        
        ```java
        //A constant holding the maximum value an int can have, 231-1.
        @Native public static final int   MAX_VALUE = 0x7fffffff;
        ```
        
    - ì¦‰, validateRange(startInclusive, endInclusive)ëŠ” startInclusiveì™€ endInclusive ê°’ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•´ì£¼ëŠ” ë©”ì†Œë“œë¼ëŠ” ê²ƒì…ë‹ˆë‹¤.
- ê·¸ë¦¬ê³  return startInclusive + defaultRandom.nextInt(endInclusive - startInclusive + 1)ì„ í†µí•´ ëœë¤ ê°’ì„ ë°˜í™˜í•´ì¤ë‹ˆë‹¤.
    - nextIntì˜ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ì´ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
        
        ```java
        @Override
            public int nextInt(int bound) {
                if (bound <= 0)
                    throw new IllegalArgumentException(BAD_BOUND);
                int r = next(31);
                int m = bound - 1;
                if ((bound & m) == 0)  // i.e., bound is a power of 2
                    r = (int)((bound * (long)r) >> 31);
                else { // reject over-represented candidates
                    for (int u = r;
                         u - (r = u % bound) + m < 0;
                         u = next(31))
                        ;
                }
                return r;
            }
        ```
        
    - nextIntì˜ ì„¤ëª…ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
        - â€œReturns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequenceâ€
        - â€œì´ ë‚œìˆ˜ ìƒì„±ê¸° ì‹œí€€ìŠ¤ì—ì„œ ê°€ì ¸ì˜¨ 0(í¬í•¨)ê³¼ ì§€ì •ëœ ê°’(ì œì™¸) ì‚¬ì´ì— ê· ì¼í•˜ê²Œ ë¶„í¬ëœ int ê°’ì„ ì˜ì‚¬ ë‚œìˆ˜ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.â€
    - ë”°ë¼ì„œ ìœ„ì˜ defaultRandom.nextInt(endInclusive - startInclusive + 1)ì½”ë“œëŠ” 0 ~ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ëŠ” ê°’ -1ê¹Œì§€ì˜ ëœë¤í•œ ìˆ˜ë¥¼ ë°˜í™˜ë°›ëŠ”ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆê³  ì €í¬ëŠ” ìˆ˜ë¥¼ 100ë¶€í„° 999ê¹Œì§€ì˜ ìˆ˜ë¥¼ ë°›ì•„ì•¼í•˜ë‹ˆ nextIntì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ 1000ìœ¼ë¡œ ë„£ì–´ì¤˜ì•¼ í•©ë‹ˆë‹¤. ë”°ë¼ì„œ endInclusive - startInclusiveëŠ” 999ê°€ ë˜ì–´ì•¼í•˜ì§€ë§Œ ë°˜í™˜ê°’ì€ ì´ì— startInclusiveì„ ë”í•´ì¤¬ìœ¼ë¯€ë¡œ endInclusive - startInclusiveëŠ” 899ê°€ ë˜ì–´ì•¼í•¨ì„ ì•Œ ìˆ˜ ìˆë‹¤.
        - ì´ë ‡ê²Œ í•œ ê²ƒì€ startInclusiveì¸ 100ë¶€í„° endInclusiveì¸ 999ê¹Œì§€ì˜ ìˆ˜ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•¨ì´ë¼ê³  ë³¼ ìˆ˜ ìˆê² ì£ ?
- ê²°ë¡ ì ìœ¼ë¡œ pickNumberInRangeëŠ” startInclusiveì™€ endInclusiveë¥¼ í¬í•¨í•˜ëŠ” ëœë¤ìˆ˜ë¥¼ ìƒì„±í•œë‹¤ê³  í™•ì¸í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ ìš°ë¦¬ëŠ” 100ê³¼ 999ë¼ëŠ” ë§¤ê°œë³€ìˆ˜ë¥¼ ì£¼ì–´ ëœë¤í•œ ìˆ˜ë¥¼ ìƒì„±í•˜ë©´ ë©ë‹ˆë‹¤.
    
    â†’ **(ë‚˜ì¤‘ì— ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ 1ë¶€í„° 9ê¹Œì§€ ëœë¤ìˆ˜ë¥¼ ìƒì„±í•˜ì—¬ ì„¸ ìë¦¬ì— ë„£ì–´ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½í•˜ì˜€ìŠµë‹ˆë‹¤!)**
    

## Console

```java
package camp.nextstep.edu.missionutils;

import java.util.Scanner;

public class Console {
    private static Scanner scanner;

    private Console() {
    }

    public static String readLine() {
        return getInstance().nextLine();
    }

    public static void close() {
        if (scanner != null) {
            scanner.close();
            scanner = null;
        }
    }

    private static Scanner getInstance() {
        if (scanner == null) {
            scanner = new Scanner(System.in);
        }
        return scanner;
    }
}
```

- Consoleí´ë˜ìŠ¤ë¥¼ ë³´ë©´ ìš°ì„  ìƒì„±ìë¥¼ ì œì™¸í•œ ëª¨ë“  í•„ë“œì™€ ë©”ì†Œë“œê°€ static ì„ ì–¸ì´ ë˜ì–´ìˆì–´ ê°ì²´ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³  ë©”ì†Œë“œë¥¼ ë°”ë¡œ í˜¸ì¶œí•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ê·¸ë¦¬ê³  í•„ë“œëŠ” Scnneríƒ€ì…ìœ¼ë¡œ scannerë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì„ ì–¸ë˜ì–´ìˆìŠµë‹ˆë‹¤.

### readLine()

- ìš°ë¦¬ê°€ ì‚¬ìš©í•´ì•¼í•  readLine() ë©”ì†Œë“œë¥¼ ë³´ë©´ getInstance().nextLine()ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
- getInstance()
    - getInstance()ëŠ” scannerê°€ nullê°’ ì¦‰, inputë°›ì€ ê°’ì´ ì—†ë‹¤ë©´ Scannerê°ì²´ë¥¼ ìƒì„±í•˜ê³  [System.in](http://System.in) ê°’ì„ ì£¼ì–´ scanner ë³€ìˆ˜ê°€ ì°¸ì¡°í•˜ë„ë¡ í•©ë‹ˆë‹¤.
    - ê·¸ë¦¬ê³  ê·¸ scannerê°’ì„ ë°˜í™˜í•´ì¤ë‹ˆë‹¤.
- getInstanceì—ì„œ ë°˜í™˜ë°›ì€ scannerê°’ì„ nextLineì´ë¼ëŠ” Scannerí´ë˜ìŠ¤ ë‚´ì¥í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ í•œì¤„ì”© ë°˜í™˜í•´ì¤ë‹ˆë‹¤.

### close()

- ì´ í´ë˜ìŠ¤ì— ì¡´ì¬í•˜ëŠ” closeë¼ëŠ” í•¨ìˆ˜ëŠ” scannerê°€ nullì´ ì•„ë‹ˆë¼ë©´ Scannerì˜ ë‚´ì¥í•¨ìˆ˜ì¸ close()ë©”ì†Œë“œë¥¼ í†µí•´ scannerë¥¼ ë‹«ì•„ì¤€ í›„ scannerê°’ì„ nullë¡œ ë§Œë“¤ì–´ ë‹¤ìŒì— ê°’ì„ ë°›ì„ ì¤€ë¹„ë¥¼ í•´ì¤ë‹ˆë‹¤!
- ê°’ì„ ì…ë ¥ë°›ê³  í•œë²ˆì˜ ìˆ«ì ê²€ì‚¬ê°€ ëë‚œí›„ closeë¥¼ ì´ìš©í•˜ì—¬ ë‹«ì•„ì£¼ë©´ ë  ê²ƒ ê°™ìŠµë‹ˆë‹¤!

## ì •ë¦¬

- ì´ë ‡ê²Œ í”„ë¦¬ì½”ìŠ¤ì—ì„œ ê¸°ë³¸ìœ¼ë¡œ ì œê³µí•´ì£¼ëŠ” APIì— ëŒ€í•´ì„œ ê³µë¶€í•´ë´¤ìŠµë‹ˆë‹¤!
- ì´ë¯¸ ì•Œê³  ìˆëŠ” ë‚´ìš©ë“¤ì€ í™•ì‹¤í•˜ê²Œ ê°œë…ì´ ì •ë¦¬ë˜ê³  ëª°ëë˜ ë‚´ìš©ë“¤ì€ ê³µë¶€ê°€ ë˜ëŠ” ê²½í—˜ì´ì—ˆë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤!
- ì›ë˜ëŠ” 100~999ì˜ ìˆ«ìë¥¼ ëœë¤ ìƒì„±í•´ì£¼ëŠ” ë¡œì§ì—ì„œ ì¤‘ê°„ì— ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ 1ì—ì„œ 9ê¹Œì§€ì˜ ìˆ˜ë¥¼ ëœë¤ ìƒì„±í•´ì£¼ê³  ì„¸ ìë¦¬ì— ë„£ì–´ì£¼ëŠ” ë¡œì§ìœ¼ë¡œ ë³€ê²½í–ˆëŠ”ë° ê°„ë‹¨í•œ ë¡œì§ ë³€ê²½ì´ì—ˆì§€ë§Œ APIë¥¼ ê³µë¶€í•˜ì—¬ ë” ì‰½ê²Œ ë°”ê¾¸ì§€ ì•Šì•˜ë‚˜ë¼ëŠ” ë¿Œë“¯í•œ ìƒê°ë„ ë“­ë‹ˆë‹¤ğŸ‘
- ì´ë ‡ê²Œ APIë¥¼ ëœ¯ì–´ë³¸ ê²½í—˜ì€ ì €ì—ê²Œ í° ì„±ì¥ì„ ê°€ì ¸ë‹¤ ì¤€ ê²ƒ ê°™ìŠµë‹ˆë‹¤!
