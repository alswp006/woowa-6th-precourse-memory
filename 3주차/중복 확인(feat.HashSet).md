- 저는 이번 미션에서 로또 번호의 랜덤 수들을 생성할 때 이미 중복된 수들을 빼려는 생각에 HashSet을 사용하여 중복을 체크하고 다시 list로 반환하여 사용할 생각이었습니다.
- 제가 이전에 읽은 책인 head first java의 부분 중 HashSet에서 중복 확인 방법이라는 내용이 있었습니다.
- 비록 지금은 중복된 수를 빼지 않고 진짜 로또를 자동으로 산다면 중복된 수가 나오는 것도 운이기에 랜덤 수 그대로 넣으려하지만 나중에…아주 나아아아중에 이런 상황에서 중복된 수를 제외해줘야하는 상황이 올 수도 있기에 미리 공부해놓으려 합니다!!
- ~~책에서 공부했던 내용 써먹을 생각에 싱글벙글하다가 필요없는거 알고 억울해서 공부하려는 마음도 있습니다..~~
- 자 그러면 공부를 해봅시다!!

## 객체들의 중복 확인

- 저는 Lotto라는 객체로 List를 만들어 사용자의 로또 번호들을 저장하고 있었습니다.
- 그래서 중복을 없애고자 HashSet으로 데이터를 받고 마지막에 List로 반환하려는 생각을 하였습니다!
- 하지만 HashSet에서는 해시코드가 다르면 같은 객체로 간주하지 않습니다.
- 따라서 같은지 확인하려는 객체들은 같은 해시코드를 가질 수 있도록 hashCode()를 오버라이드해야 합니다.
- 하지만 해시코드가 같아도 두 객체가 같지 않을 수 있기 때문에 HashSet에서는 같은 해시코드를 가지는 두 객체에 대해 equals()메소드를 통해 두 객체가 정말 같은지를 판별합니다
- 이렇게 HashCode()와 equals()메소드를 적절하게 오버라이드 했을 때 두 객체가 같은 것으로 나온다면 HashSet에서는 추가하려는 객체가 중복되었다고 생각하고 새 객체를 추가하지 않습니다!!!

### HashCode()와 equals()와 관련된 규칙

- API 문서의 Object 클래스에서 나타난 규칙은 다음과 같습니다.
    - 두 객체가 같으면 반드시 같은 해시코드를 가져야 한다.
    - 두 객체가 같으면 equals()메소드를 호출했을 때 true를 리턴해야 한다.
    - 두 객체의 해시코드 값이 같다고 반드시 객체가 같은 것은 아니지만 두 객체가 같으면 두 해시코드는 반드시 같아야 한다.
    - equals()를 오버라이드하면 반드시 hashCode()도 오버라이드해야한다.
    - hashCode()는 힙에 있는 각 객체마다 서로 다른 값을 가지는 유일한 정수를 리턴하기에 오버라이드하지 않으면 두 객체가 같은 것으로 간주될 수 없다.
    - equals()메소드는 기본적으로 “==”연산자를 써서 객체를 비교(레퍼런스가 참조하는 객체가 같은지)하기 때문에 오버라이드를 하지않으면 두 객체가 같은 것으로 간주될 수 없다.
    - a.equals(b)==true 이면 a.hashCode() == a.hashCode()이다.
    - a.hashCode() == a.hashCode()이라도 a.equals(b)==true는 아닐수도 있다.

### 결과

- 그리하여 저는 아래와 같이 오버라이드를 해줬습니다!

```java
		@Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        Lotto lotto = (Lotto) obj;
        return Objects.equals(numbers, lotto.numbers);
    }

		@Override
    public int hashCode() {
        return Objects.hash(numbers);
    }
```

- 테스트 코드는 아래와 같이 구성하여 테스트해봤습니다!

```java
  	@DisplayName("로또 번호가 잘 생성되는지 테스트")
    @Test
    void create_lotto_Test() {
        assertRandomUniqueNumbersInRangeTest(() -> {
                    run("2000","1,2,3,4,5,6","7");
                    assertThat(output()).contains(
                            "[8, 21, 23, 41, 42, 43]",
                            "[7, 21, 23, 41, 42, 43]");
                },
                List.of(8, 21, 23, 41, 42, 43),
                List.of(8, 21, 23, 41, 42, 43),
                List.of(7, 21, 23, 41, 42, 43)
        );
    }
```

- 테스트 코드가 잘 돌아가는 것을 확인했습니다!

## 회고

- 비록 중복을 제거할 필요가 없다는 것을 늦게 깨달아 바보짓을 했지만 프리코스의 목적은 공부라는 것을 생각하면 낭비한 시간은 아니었던 것 같습니다!
- 책에서 공부했던 내용을 직접 사용할 수 있다고 생각하니 정말 기분이 좋았었고 뿌듯했습니다!
- 책을 좀 더 열심히 읽는 계기가 될 것 같아 좋은 경험이었던 것 같습니다!!
