- 저는 4주차 미션인 크리스마스 포로모션을 수행하며 틈틈히 쉬는 시간에 헤드 퍼스트 디자인 패턴이라는 책을 읽고 있습니다!
- 헤드 퍼스트 디자인 패턴을 읽던 와중 전략 패턴이라는 것을 발견했고 전략패턴의 “바뀌는 부분은 따로 뽑아서 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.”라는 부분이 4주차 미션에서 할인 기능에 적용할 수 있을 것 같아 전략패턴을 공부하여 사용해보려 합니다!

# 전략 패턴

- 전략 패턴이란 객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의하여, 객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 변경함으로써 행위를 유연하게 확장하는 방법을 말합니다.
- 전략패턴은 행동을 서브클래스에서 정의한 메소드를 사용하여 구현하지 않고 전략 클래스에 위임합니다.
- 이러한 패턴을 사용하면 OCP에 위배되지 않고 시스템이 거대해졌을 때, 메소드의 중복을 해결할 수 있습니다.
- 전략 패턴은 유연성, 재사용성이라는 장점이 있지만 클래스 수의 증가라는 단점이 있습니다.
    - 유연성 : 전략 패턴을 사용하면 알고리즘을 사용하는 클라이언트와 알고리즘을 독립적으로 변경할 수 있기 때문에 클라이언트의 유연성이 증가하고, 알고리즘의 변경이나 확장을 유연하게 처리할 수 있습니다.
    - 재사용성 : 전략 패턴을 사용하면 알고리즘을 독립적인 클래스로 분리해놓았기 때문에 알고리즘을 재사용할 수 있습니다.
    - 클래수 수의 증가 : 전략 패턴에서는 전략을 클래스로 만들기 때문에 전략의 수만큼 클래스가 증가하게 됩니다. 이는 복잡성을 증가시킵니다.

# 책의 예제

- 만약 오리를 나타내는 클래스가 있다고 합니다. 오리는 헤엄도 치고 소리도 낼 수 있습니다. 여기에 나는 기능을 추가하려 합니다. 이를 어떻게 추가할 수 있을까요
1. 상속을 통해 모든 오리에 fly()메소드를 추가해준다.
    
    → 날아서는 안되는 오리들도 날게 된다.
    
    → 오버라이드로 한 개씩 바꿔주면 다른 기능을 추가하거나 변경할 때 클래스 마다 다 확인하고 변경하거나 오버라이드해줘야한다.
    
2. 인터페이스를 설계하여 fly()메소드 메소드를 넣어 날아야하는 클래스에만 구현해준다.
    
    → 코드 중복이 생긴다.
    
    → 이 또한 변경을 해야할 때 클래스마다 코드를 변경해줘야 한다.
    
3. 전략 패턴을 사용한다⭐️
    - 바뀌는 부분과 바뀌지 않는 부분을 분리한다.
    - 바뀌지 않는 부분은 그대로 두고 바뀌는 부분을 분리한다.
    - 각 행동을 구현한 클래스를 만든다.
    - 예를 들면 꽥꽥거리는 클래스를 만들고 삑삑거리는 행동을 구현하는 클래스와 아무 소리도 내지않는 클래스를 만든다. → 클래스 집합
    - 위 클래스들은 소리를 내는 인터페이스를 구현받아 그 인터페이스의 메소드를 구현한다.

# 디자인 원칙

- 애플리케이션에서 달라지는 부분을 찾아내고 달라지지 않는 부분과 분리한다.
    - 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 캡슐화한다.
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
- 상속보다는 구성을 활용한다.
    - “A에는 B가 있다”라는 관계를 생각해보자.
    - 각 오리에는 FlyBehavior와 QuackBehavior가 있으며 각각 나는 행동과 꽥꽥거리는 행동을 위임받는다.
    - 이런 식으로 두 클래스를 합치는 것을 구성을 이용한다러고 부른다.
    - 여기에서 오리 클래스는 행동을 상속받는 대신 올바른 행동 객체로 구성되어 행동을 부여받는다.

# 정리

- 정리해보면 전략 패턴은 객체의 행위를 동적으로 바꾸고 싶을 때, 해당 행위를 직접 수정하지 않고 전략 클래스를 생성하여 행위를 캡슐화하고, 이를 변경함으로써 행위를 유연하게 확장할 수 있는 디자인 패턴입니다!
- 정말 객체 지향에 초점을 둔 패턴이라고 생각합니다!
- 이제 전략 패턴을 공부하였으니 가장 중요한 적용을 해보겠습니다!
